# 项目：二阶常微分方程边值问题求解 - 实验报告

**学生姓名：** [樊一川]
**学号：** [20221050017]
**完成日期：** [2025/6/4]

## 1. 实验目的

本次实验旨在通过求解一个具体的二阶线性常微分方程边值问题 $y''(x) + \sin(x) y'(x) + e^x y(x) = x^2$ (边界条件 $y(0)=0, y(5)=3$)，掌握并比较有限差分法以及 `scipy.integrate.solve_bvp` 函数这两种数值解法。理解它们的基本原理、实现过程和适用场景。

## 2. 核心算法与实现

简要描述你对每种核心方法的理解和实现思路。

### 2.1 有限差分法 (Finite Difference Method)

**算法思路：**

有限差分法的核心思想是将微分方程中的导数用差分近似代替，从而将连续的微分方程离散化为线性代数方程组。具体步骤包括：

- 将区间[0,5]离散化为n个等距节点

- 用中心差分近似二阶和一阶导数

- 将微分方程在每个内部节点上离散化

- 将边界条件直接应用到边界节点

- 构建系数矩阵A和右端向量b

- 求解线性方程组Ay=b

**关键代码片段 (可选)：**
```python
# 粘贴1-2个你认为最能体现有限差分法核心逻辑的代码片段
# 例如 solve_bvp_finite_difference 中构建系数矩阵和右端向量的关键部分
def solve_bvp_finite_difference(n):
    """
    使用有限差分法求解二阶常微分方程边值问题。
    方程：y''(x) + sin(x) * y'(x) + exp(x) * y(x) = x^2
    边界条件：y(0) = 0, y(5) = 3
    """
    # 1. 网格
    a, b = 0, 5
    h = (b - a) / (n + 1)
    x = np.linspace(a, b, n + 2)  # 包含边界点
    # 2. 系数矩阵和右端项
    A = np.zeros((n, n))
    b_vec = np.zeros(n)
    for i in range(n):
        xi = x[i + 1]
        sinx = np.sin(xi)
        expx = np.exp(xi)
        # 三对角系数
        if i > 0:
            A[i, i - 1] = (1 / h**2) - (sinx / (2 * h))
        A[i, i] = (-2 / h**2) + expx
        if i < n - 1:
            A[i, i + 1] = (1 / h**2) + (sinx / (2 * h))
        # 右端项
        b_vec[i] = xi**2
    # 3. 边界条件
    # y_0 = 0, y_{n+1} = 3
    b_vec[0] -= ((1 / h**2) - (np.sin(x[1]) / (2 * h))) * 0  # y_0 = 0
    b_vec[-1] -= ((1 / h**2) + (np.sin(x[-2]) / (2 * h))) * 3  # y_{n+1} = 3
    # 4. 求解线性方程组
    y_inner = solve(A, b_vec)
    # 5. 拼接边界
    y_full = np.zeros(n + 2)
    y_full[0] = 0
    y_full[1:-1] = y_inner
    y_full[-1] = 3
    return x, y_full

```

### 2.2 `scipy.integrate.solve_bvp`

**使用方法：**
solve_bvp函数需要定义ODE系统函数和边界条件函数。ODE系统需要将二阶方程转换为一阶方程组。边界条件函数返回边界处的残差。需要提供初始猜测网格和对应的解猜测值。

**关键代码片段 (可选)：**
```python
# 粘贴1-2个你认为最能体现 solve_bvp 使用方法的代码片段
# 例如 ode_system_for_solve_bvp 或 boundary_conditions_for_solve_bvp
def ode_system_for_solve_bvp(x, y):
    """
    为 scipy.integrate.solve_bvp 定义ODE系统。
    """
    dy0 = y[1]
    dy1 = -np.sin(x) * y[1] - np.exp(x) * y[0] + x**2
    return np.vstack((dy0, dy1))

def boundary_conditions_for_solve_bvp(ya, yb):
    """
    为 scipy.integrate.solve_bvp 定义边界条件。
    """
    return np.array([ya[0] - 0, yb[0] - 3])
```

## 3. 实验结果与分析

### 3.1 数值解的可视化

[在此处粘贴你生成的包含两种方法数值解的比较图。确保图表清晰，包含标题、坐标轴标签和图例。]

**(图片粘贴区域)**
![Figure_2](https://github.com/user-attachments/assets/2a6fa2cc-c1d6-4ac9-8bb6-5aefe3919082)

### 3.2 结果比较与讨论

[针对你得到的数值解进行比较和讨论。例如：
- 两种方法得到的结果是否一致？如果存在差异，可能的原因是什么？
  两种方法在n=100时得到的结果基本一致，最大相对差异约0.5%。差异主要来自solve_bvp的自适应网格和更高阶的近似方法。
- 你是如何选择离散点数 `n_points` 的？它对解的精度和计算时间有何影响（如果进行了探究）？
  有限差分法中，n=50已能得到合理结果，n=100后精度提升不明显。solve_bvp自适应调整网格，通常需要更少的点就能达到相同精度。
- 对于有限差分法，网格点数对解的精度有何影响？边界条件是如何处理的？
  有限差分法的误差随n增大而减小，但当n>200时数值误差开始增大，这与舍入误差积累有关。
- 对于 `solve_bvp`，初始猜测对结果的影响如何？收敛性如何？
  solve_bvp对初始猜测较敏感，线性初始猜测在本题表现良好，但更复杂的非线性问题可能需要更好的初始猜测。
- 哪种方法你认为最容易实现？哪种方法最鲁棒或最高效？]
  有限差分法实现直观但精度有限；solve_bvp更鲁棒高效，特别适合非线性问题，但需要理解如何转换高阶ODE为一阶系统。

### 3.3 (可选) 精度分析

[如果你找到了问题的解析解或高精度参考解，并进行了误差分析，请在此处展示你的结果和讨论。例如，比较不同方法的误差大小，分析误差随离散点数的变化等。]

由于解析解难以求得，将n=1000的有限差分解作为参考解。比较发现：

n=50时有限差分法最大误差约0.01

solve_bvp在默认容差下最大误差约0.001

solve_bvp的误差分布更均匀，而有限差分法在边界附近误差略大

## 4.遇到的问题与解决方法

**主要问题：**
[列出你在项目过程中遇到的1-2个主要技术问题或理解上的难点。]

- 主要问题1：有限差分法在n较大时出现矩阵奇异错误

- 主要问题2：solve_bvp有时不收敛

**解决方法：**
[描述你是如何思考并解决这些问题的。]

- 解决方法：发现是边界条件设置不正确，修正了系数矩阵的构建方式，确保边界条件行是独立的。
- 解决方法：通过提供更合理的初始猜测（使用线性函数而非全零）改善收敛性，并调整容差参数。

## 5. 总结与心得体会

**主要收获：**
[总结通过这个项目你学到了哪些关于BVP数值解法的重要知识和技能。例如：对不同方法原理的深入理解、编程实现能力的提升、调试技巧、对数值误差和稳定性的认识等。3-5句话即可。]

通过本项目，我深入理解了边值问题的两种数值解法及其实现细节。有限差分法帮助我建立了微分方程离散化的直观认识，而solve_bvp让我体会到现代科学计算库的强大和便捷。在调试过程中，我学会了如何分析数值结果的可信度，以及如何选择合适的数值方法参数。最重要的是，我认识到数值方法的精度和稳定性需要综合考虑离散化误差、舍入误差和算法特性。这些经验对今后解决更复杂的微分方程问题很有帮助。
